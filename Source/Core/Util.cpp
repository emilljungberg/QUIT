/*
 *  Util.cpp
 *  Part of the QUantitative Image Toolbox
 *
 *  Copyright (c) 2015 Tobias Wood.
 *
 *  This Source Code Form is subject to the terms of the Mozilla Public
 *  License, v. 2.0. If a copy of the MPL was not distributed with this
 *  file, You can obtain one at http://mozilla.org/MPL/2.0/.
 *
 */
#include <fstream>

#include "itkVectorMagnitudeImageFilter.h"
#include "itkMultiplyImageFilter.h"
#include "itkDivideImageFilter.h"

#include "Util.h"
#include "IO.h"

namespace QI {

const std::string &GetVersion() {
    // This file is generated by CMake to create a static version string
    #include "VersionFile"
    return Version;
}

/*
 * This function checks the environment variable QUIT_EXT. If it does not exist,
 * a default value is returned. If it exists, and is one of the FSL output-types
 * the matching extension is returned. Otherwise, it is assumed that the
 * environment variable is a valid extension, including the ., and it is
 * returned.
 */
const std::string &OutExt() {
    static char *env_ext = getenv("QUIT_EXT");
    static std::string ext;
    static bool checked = false;
    if (!checked) {
        static std::map<std::string, std::string> valid_ext{
            {"NIFTI", ".nii"},
            {"NIFTI_PAIR", ".img"},
            {"NIFTI_GZ", ".nii.gz"},
            {"NIFTI_PAIR_GZ", ".img.gz"},
        };
        if (!env_ext) {
            std::cerr << "Environment variable QUIT_EXT is not valid, defaulting to NIFTI_GZ" << std::endl;
            ext = valid_ext["NIFTI_GZ"];
        } else if (valid_ext.find(env_ext) == valid_ext.end()){
            ext = env_ext;
        } else {
            ext = valid_ext[env_ext];
        }
        checked = true;
    }
    return ext;
}

std::string StripExt(const std::string &filename) {
    std::size_t dot = filename.find_last_of(".");
    if (dot != std::string::npos) {
        /* Deal with .nii.gz files */
        if (filename.substr(dot) == ".gz") {
            dot = filename.find_last_of(".", dot - 1);
        }
        return filename.substr(0, dot);
    } else {
        return filename;
    }
}

std::string GetExt(const std::string &filename) {
    std::size_t dot = filename.find_last_of(".");
    if (dot != std::string::npos) {
        /* Deal with .nii.gz files */
        if (filename.substr(dot) == ".gz") {
            dot = filename.find_last_of(".", dot - 1);
        }
        return filename.substr(dot);
    } else {
        QI_EXCEPTION("No extension found in string: " << filename);
    }
}

std::string Basename(const std::string &path) {
    std::size_t slash = path.find_last_of("/");
    if (slash != std::string::npos) {
        return StripExt(path.substr(slash + 1));
    } else {
        return StripExt(path);
    }
}

std::mt19937_64::result_type RandomSeed() {
    static std::random_device rd;
    static std::mt19937_64 rng;
    static bool init = false;
    std::mutex seed_mtx;
    if (!init) {
        rng = std::mt19937_64(rd());
    }
    seed_mtx.lock();
    std::mt19937_64::result_type r = rng();
    seed_mtx.unlock();
    return r;
}

// From Knuth, surprised this isn't in STL
unsigned long long Choose(unsigned long long n, unsigned long long k) {
    if (k > n)
        return 0;

    unsigned long long r = 1;
    for (unsigned long long d = 1; d <= k; ++d) {
        r *= n--;
        r /= d;
    }
    return r;
}

// Utility function to read a file into an array, ignoring comment lines
Eigen::ArrayXXd ReadArrayFile(const std::string &path) {
    std::ifstream matrix_file(path);
    if (!matrix_file) {
        QI_EXCEPTION("Failed to open design matrix: " << path << std::endl);
    }
    while (matrix_file && (matrix_file.peek() == '/')) {
        matrix_file.ignore(std::numeric_limits<std::streamsize>::max(), '\n');
    }
    Eigen::ArrayXXd matrix;
    QI::ReadArray(matrix_file, matrix);
    return matrix;
}

void GenericMonitor::Execute(itk::Object *caller, const itk::EventObject &event) {
    Execute((const itk::Object *)caller, event);
}
void GenericMonitor::Execute(const itk::Object *object, const itk::EventObject &event) {
    const itk::ProcessObject *filter = static_cast<const itk::ProcessObject *>(object);
    if (typeid(event) == typeid(itk::ProgressEvent)) {
        std::cout << "Progress: " << round(filter->GetProgress()*100) << "% complete" << std::endl;
    } else {
        std::cout << "Received event: " << typeid(event).name() << std::endl;
    }
}

} // End namespace QUIT
